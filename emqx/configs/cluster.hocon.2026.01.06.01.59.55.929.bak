# This file is generated. Do not edit.
# The configs are results of online config changes from UI/API/CLI.
# To persist configs in this file, copy the content to etc/base.hocon.
actions {
  http {
    webhook_WH_D {
      connector = webhook_WH_D
      created_at = 1758120115875
      enable = true
      fallback_actions = []
      last_modified_at = 1758120781996
      parameters {
        headers {content-type = "application/json"}
        max_retries = 2
        method = post
      }
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
        inflight_window = 100
        max_buffer_bytes = "256MB"
        query_mode = async
        request_ttl = "45s"
        worker_pool_size = 16
      }
      tags = []
    }
  }
}
authentication = [
  {
    backend = http
    body {
      clientId = "${clientid}"
      password = "${password}"
    }
    connect_timeout = "15s"
    enable = true
    enable_pipelining = 100
    headers {content-type = "application/json"}
    max_inactive = "10s"
    mechanism = password_based
    method = post
    pool_size = 8
    precondition = ""
    request_timeout = "5s"
    ssl {
      ciphers = []
      depth = 10
      enable = false
      hibernate_after = "5s"
      log_level = notice
      middlebox_comp_mode = true
      reuse_sessions = true
      secure_renegotiate = true
      verify = verify_peer
      versions = [
        "tlsv1.3",
        "tlsv1.2"
      ]
    }
    url = "http://mqtt-handler:3002/api/mqtt/auth"
  }
]
authorization {
  cache {
    enable = true
    excludes = []
    max_size = 32
    ttl = "1m"
  }
  deny_action = ignore
  no_match = allow
  node_cache {
    cache_ttl = "1m"
    enable = false
    max_count = 1000000
    max_memory = "100MB"
  }
  sources = [
    {
      body {
        action = "${action}"
        authorization = "${client_attrs.authorization}"
        clientId = "${clientid}"
        internalId = "${client_attrs.internal_id}"
        topic = "${topic}"
      }
      connect_timeout = "15s"
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      max_inactive = "10s"
      method = post
      pool_size = 8
      request_timeout = "30s"
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = "5s"
        log_level = notice
        middlebox_comp_mode = true
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_peer
        versions = [
          "tlsv1.3",
          "tlsv1.2"
        ]
      }
      type = http
      url = "http://host.docker.internal:3002/api/mqtt/acl"
    }
  ]
}
connectors {
  http {
    webhook_WH_D {
      connect_timeout = "15s"
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      max_inactive = "10s"
      pool_size = 8
      pool_type = random
      resource_opts {
        health_check_interval = "15s"
        health_check_timeout = "60s"
        start_after_created = true
        start_timeout = "5s"
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = "5s"
        log_level = notice
        middlebox_comp_mode = true
        partial_chain = true
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [
          "tlsv1.3",
          "tlsv1.2"
        ]
      }
      tags = []
      url = "http://mqtt-handler:3002/api/mqtt/status"
    }
  }
}
log {
  console {}
  file {}
}
mqtt {
  await_rel_timeout = "300s"
  client_attrs_init = []
  clientid_override = disabled
  exclusive_subscription = false
  idle_timeout = "30s"
  ignore_loop_deliver = false
  keepalive_check_interval = "60s"
  keepalive_multiplier = 2
  max_awaiting_rel = 100
  max_clientid_len = 65535
  max_inflight = 32
  max_mqueue_len = 1000
  max_packet_size = "1MB"
  max_qos_allowed = 1
  max_subscriptions = infinity
  max_topic_alias = 65535
  max_topic_levels = 128
  message_expiry_interval = infinity
  mqueue_default_priority = lowest
  mqueue_priorities = disabled
  mqueue_store_qos0 = true
  peer_cert_as_clientid = disabled
  peer_cert_as_username = disabled
  response_information = null
  retain_available = true
  retry_interval = infinity
  server_keepalive = 300
  session_expiry_interval = "2h"
  shared_subscription = true
  shared_subscription_initial_sticky_pick = random
  shared_subscription_strategy = round_robin
  strict_mode = false
  upgrade_qos = false
  use_username_as_clientid = false
  wildcard_subscription = true
}
rule_engine {
  ignore_sys_message = true
  jq_function_default_timeout = "10s"
  rules {
    rule_gpdj {
      actions = [
        {
          args {
            direct_dispatch = false
            mqtt_properties {}
            payload = """~
              {
                "clientId": "${clientid}",
                "internalId": "${client_attrs.internal_id}",
                "authorization": "${client_attrs.authorization}",
                "topic": "${topic}",
                "payload": ${payload}
              }
            ~"""
            qos = "${qos}"
            retain = "${flags.retain}"
            topic = "enriched/${topic}"
            user_properties = ""
          }
          function = republish
        }
      ]
      description = ""
      enable = true
      metadata {last_modified_at = 1761877742513}
      name = ""
      sql = """~
        SELECT
          client_attrs,
          clientid,
          topic,
          payload
        FROM
        "client/#"~"""
    }
    webhook_WH_D {
      actions = [
        "http:webhook_WH_D"
      ]
      description = ""
      enable = true
      metadata {last_modified_at = 1758120782037}
      name = ""
      sql = """~
        SELECT
          *
        FROM
          "$events/client/connected",
          "$events/client/disconnected"~"""
    }
  }
}
